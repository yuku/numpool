// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acquireAdvisoryLock = `-- name: AcquireAdvisoryLock :exec
SELECT pg_advisory_xact_lock($1)
`

func (q *Queries) AcquireAdvisoryLock(ctx context.Context, lockID int64) error {
	_, err := q.db.Exec(ctx, acquireAdvisoryLock, lockID)
	return err
}

const acquireResource = `-- name: AcquireResource :execrows
UPDATE numpools
SET resource_usage_status = resource_usage_status | (1::BIT(64) << (63 - $2))
WHERE id = $1
  AND (resource_usage_status & (1::BIT(64) << (63 - $2))) = 0::BIT(64)
`

type AcquireResourceParams struct {
	ID            string
	ResourceIndex interface{}
}

// AcquireResource attempts to acquire a resource from the numpool.
// It returns the id of the numpool if successful, or NULL if no resources are available.
func (q *Queries) AcquireResource(ctx context.Context, arg AcquireResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, acquireResource, arg.ID, arg.ResourceIndex)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const checkNumpoolExists = `-- name: CheckNumpoolExists :one
SELECT EXISTS (
    SELECT 1
    FROM numpools
    WHERE id = $1
) AS exists
`

// CheckNumpoolExists checks if a numpool with the given id exists.
func (q *Queries) CheckNumpoolExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, checkNumpoolExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkNumpoolTableExist = `-- name: CheckNumpoolTableExist :one
SELECT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = 'public'
      AND table_name = 'numpools'
) AS exists
`

// CheckNumpoolTableExist checks if "public"."numpool" exists.
func (q *Queries) CheckNumpoolTableExist(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkNumpoolTableExist)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createNumpool = `-- name: CreateNumpool :exec
INSERT INTO numpools (id, max_resources_count, metadata)
VALUES ($1, $2, $3)
`

type CreateNumpoolParams struct {
	ID                string
	MaxResourcesCount int32
	Metadata          []byte
}

// CreateNumpool creates a new numpool with the specified id and max_resources_count.
func (q *Queries) CreateNumpool(ctx context.Context, arg CreateNumpoolParams) error {
	_, err := q.db.Exec(ctx, createNumpool, arg.ID, arg.MaxResourcesCount, arg.Metadata)
	return err
}

const deleteNumpool = `-- name: DeleteNumpool :execrows
DELETE FROM numpools WHERE id = $1
`

// DeleteNumpool deletes the numpool with the specified id.
func (q *Queries) DeleteNumpool(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNumpool, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const dropNumpoolTable = `-- name: DropNumpoolTable :exec
DROP TABLE IF EXISTS numpools
`

// DropNumpoolTable drops the numpool table if it exists.
func (q *Queries) DropNumpoolTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropNumpoolTable)
	return err
}

const enqueueWaitingClient = `-- name: EnqueueWaitingClient :exec
UPDATE numpools
SET wait_queue = array_append(wait_queue, $2::VARCHAR(100))
WHERE id = $1
`

type EnqueueWaitingClientParams struct {
	ID       string
	WaiterID string
}

// EnqueueWaitingClient adds a waiter ID to the wait queue.
func (q *Queries) EnqueueWaitingClient(ctx context.Context, arg EnqueueWaitingClientParams) error {
	_, err := q.db.Exec(ctx, enqueueWaitingClient, arg.ID, arg.WaiterID)
	return err
}

const getNumpool = `-- name: GetNumpool :one
SELECT id, max_resources_count, resource_usage_status, wait_queue, metadata FROM numpools WHERE id = $1
`

// GetNumpoolForUpdate retrieves the numpool row with the given id without locking it.
func (q *Queries) GetNumpool(ctx context.Context, id string) (Numpool, error) {
	row := q.db.QueryRow(ctx, getNumpool, id)
	var i Numpool
	err := row.Scan(
		&i.ID,
		&i.MaxResourcesCount,
		&i.ResourceUsageStatus,
		&i.WaitQueue,
		&i.Metadata,
	)
	return i, err
}

const getNumpoolForUpdate = `-- name: GetNumpoolForUpdate :one
SELECT id, max_resources_count, resource_usage_status, wait_queue, metadata FROM numpools WHERE id = $1 FOR UPDATE
`

// GetNumpoolForUpdate retrieves the numpool row with the given id and locks it for update.
func (q *Queries) GetNumpoolForUpdate(ctx context.Context, id string) (Numpool, error) {
	row := q.db.QueryRow(ctx, getNumpoolForUpdate, id)
	var i Numpool
	err := row.Scan(
		&i.ID,
		&i.MaxResourcesCount,
		&i.ResourceUsageStatus,
		&i.WaitQueue,
		&i.Metadata,
	)
	return i, err
}

const listPools = `-- name: ListPools :many
SELECT id FROM numpools
WHERE id LIKE $1 || '%'
ORDER BY id
`

// ListPools returns a list of pool names that start with the given prefix.
// If prefix is empty, returns all pools ordered by pool name.
func (q *Queries) ListPools(ctx context.Context, prefix pgtype.Text) ([]string, error) {
	rows, err := q.db.Query(ctx, listPools, prefix)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockNumpoolTableInShareMode = `-- name: LockNumpoolTableInShareMode :exec
LOCK TABLE numpools IN SHARE ROW EXCLUSIVE MODE
`

func (q *Queries) LockNumpoolTableInShareMode(ctx context.Context) error {
	_, err := q.db.Exec(ctx, lockNumpoolTableInShareMode)
	return err
}

const notifyAndDequeueFirstWaiter = `-- name: NotifyAndDequeueFirstWaiter :exec
WITH first_waiter AS (
  SELECT wait_queue[1] as waiter_id FROM numpools WHERE numpools.id = $1 AND cardinality(wait_queue) > 0
),
updated AS (
  UPDATE numpools
  SET wait_queue = wait_queue[2:]
  WHERE numpools.id = $1 AND cardinality(wait_queue) > 0
  RETURNING true
)
SELECT pg_notify($2, first_waiter.waiter_id)
FROM first_waiter, updated
WHERE first_waiter.waiter_id IS NOT NULL
`

type NotifyAndDequeueFirstWaiterParams struct {
	ID          string
	ChannelName string
}

// NotifyAndDequeueFirstWaiter atomically dequeues the first waiter and notifies them.
// This prevents the race condition where multiple releases notify the same waiter.
func (q *Queries) NotifyAndDequeueFirstWaiter(ctx context.Context, arg NotifyAndDequeueFirstWaiterParams) error {
	_, err := q.db.Exec(ctx, notifyAndDequeueFirstWaiter, arg.ID, arg.ChannelName)
	return err
}

const notifyWaiters = `-- name: NotifyWaiters :exec
SELECT pg_notify($1, $2)
`

type NotifyWaitersParams struct {
	ChannelName string
	WaiterID    string
}

func (q *Queries) NotifyWaiters(ctx context.Context, arg NotifyWaitersParams) error {
	_, err := q.db.Exec(ctx, notifyWaiters, arg.ChannelName, arg.WaiterID)
	return err
}

const releaseResource = `-- name: ReleaseResource :execrows
UPDATE numpools
SET resource_usage_status = resource_usage_status & ~(1::BIT(64) << (63 - $2))
WHERE id = $1
	AND (resource_usage_status & (1::BIT(64) << (63 - $2))) <> 0::BIT(64)
`

type ReleaseResourceParams struct {
	ID            string
	ResourceIndex interface{}
}

// ReleaseResource releases a resource back to the numpool.
func (q *Queries) ReleaseResource(ctx context.Context, arg ReleaseResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseResource, arg.ID, arg.ResourceIndex)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeFromWaitQueue = `-- name: RemoveFromWaitQueue :exec
UPDATE numpools
SET wait_queue = array_remove(wait_queue, $2)
WHERE id = $1
`

type RemoveFromWaitQueueParams struct {
	ID       string
	WaiterID interface{}
}

// RemoveFromWaitQueue removes a specific waiter UUID from the wait queue.
func (q *Queries) RemoveFromWaitQueue(ctx context.Context, arg RemoveFromWaitQueueParams) error {
	_, err := q.db.Exec(ctx, removeFromWaitQueue, arg.ID, arg.WaiterID)
	return err
}

const updateNumpoolMetadata = `-- name: UpdateNumpoolMetadata :exec
UPDATE numpools
SET metadata = $2
WHERE id = $1
`

type UpdateNumpoolMetadataParams struct {
	ID       string
	Metadata []byte
}

// UpdateNumpoolMetadata updates the metadata of the numpool with the specified id.
func (q *Queries) UpdateNumpoolMetadata(ctx context.Context, arg UpdateNumpoolMetadataParams) error {
	_, err := q.db.Exec(ctx, updateNumpoolMetadata, arg.ID, arg.Metadata)
	return err
}
