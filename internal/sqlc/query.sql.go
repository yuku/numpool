// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
)

const acquireAdvisoryLock = `-- name: AcquireAdvisoryLock :exec
SELECT pg_advisory_xact_lock($1)
`

func (q *Queries) AcquireAdvisoryLock(ctx context.Context, lockID int64) error {
	_, err := q.db.Exec(ctx, acquireAdvisoryLock, lockID)
	return err
}

const acquireResource = `-- name: AcquireResource :execrows
UPDATE numpools
SET resource_usage_status = resource_usage_status | (1::BIT(64) << (63 - $2))
WHERE id = $1
  AND (resource_usage_status & (1::BIT(64) << (63 - $2))) = 0::BIT(64)
`

type AcquireResourceParams struct {
	ID            string
	ResourceIndex interface{}
}

// AcquireResource attempts to acquire a resource from the numpool.
// It returns the id of the numpool if successful, or NULL if no resources are available.
func (q *Queries) AcquireResource(ctx context.Context, arg AcquireResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, acquireResource, arg.ID, arg.ResourceIndex)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const acquireResourceAndDequeueFirstWaiter = `-- name: AcquireResourceAndDequeueFirstWaiter :execrows
UPDATE numpools
SET
  resource_usage_status = resource_usage_status | (1::BIT(64) << (63 - $2::INTEGER)),
  wait_queue = wait_queue[2:]
WHERE id = $1
  AND (resource_usage_status & (1::BIT(64) << (63 - $2))) = 0::BIT(64)
  AND cardinality(wait_queue) > 0
  AND wait_queue[1] = $3::VARCHAR(100)
`

type AcquireResourceAndDequeueFirstWaiterParams struct {
	ID            string
	ResourceIndex int32
	WaiterID      string
}

// AcquireResourceAndDequeueFirstWaiter attempts to acquire a resource and dequeue the first client
// from the wait queue if successful.
func (q *Queries) AcquireResourceAndDequeueFirstWaiter(ctx context.Context, arg AcquireResourceAndDequeueFirstWaiterParams) (int64, error) {
	result, err := q.db.Exec(ctx, acquireResourceAndDequeueFirstWaiter, arg.ID, arg.ResourceIndex, arg.WaiterID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const checkNumpoolExists = `-- name: CheckNumpoolExists :one
SELECT EXISTS (
    SELECT 1
    FROM numpools
    WHERE id = $1
) AS exists
`

// CheckNumpoolExists checks if a numpool with the given id exists.
func (q *Queries) CheckNumpoolExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, checkNumpoolExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkNumpoolTableExist = `-- name: CheckNumpoolTableExist :one
SELECT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = 'public'
      AND table_name = 'numpools'
) AS exists
`

// CheckNumpoolTableExist checks if "public"."numpool" exists.
func (q *Queries) CheckNumpoolTableExist(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkNumpoolTableExist)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createNumpool = `-- name: CreateNumpool :exec
INSERT INTO numpools (id, max_resources_count, metadata)
VALUES ($1, $2, $3)
`

type CreateNumpoolParams struct {
	ID                string
	MaxResourcesCount int32
	Metadata          []byte
}

// CreateNumpool creates a new numpool with the specified id and max_resources_count.
func (q *Queries) CreateNumpool(ctx context.Context, arg CreateNumpoolParams) error {
	_, err := q.db.Exec(ctx, createNumpool, arg.ID, arg.MaxResourcesCount, arg.Metadata)
	return err
}

const deleteNumpool = `-- name: DeleteNumpool :execrows
DELETE FROM numpools WHERE id = $1
`

// DeleteNumpool deletes the numpool with the specified id.
func (q *Queries) DeleteNumpool(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNumpool, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const enqueueWaitingClient = `-- name: EnqueueWaitingClient :exec
UPDATE numpools
SET wait_queue = array_append(wait_queue, $2::VARCHAR(100))
WHERE id = $1
`

type EnqueueWaitingClientParams struct {
	ID       string
	WaiterID string
}

// EnqueueWaitingClient adds a waiter ID to the wait queue.
func (q *Queries) EnqueueWaitingClient(ctx context.Context, arg EnqueueWaitingClientParams) error {
	_, err := q.db.Exec(ctx, enqueueWaitingClient, arg.ID, arg.WaiterID)
	return err
}

const getNumpool = `-- name: GetNumpool :one
SELECT id, max_resources_count, resource_usage_status, wait_queue, metadata FROM numpools WHERE id = $1
`

// GetNumpoolForUpdate retrieves the numpool row with the given id without locking it.
func (q *Queries) GetNumpool(ctx context.Context, id string) (Numpool, error) {
	row := q.db.QueryRow(ctx, getNumpool, id)
	var i Numpool
	err := row.Scan(
		&i.ID,
		&i.MaxResourcesCount,
		&i.ResourceUsageStatus,
		&i.WaitQueue,
		&i.Metadata,
	)
	return i, err
}

const getNumpoolForUpdate = `-- name: GetNumpoolForUpdate :one
SELECT id, max_resources_count, resource_usage_status, wait_queue, metadata FROM numpools WHERE id = $1 FOR UPDATE
`

// GetNumpoolForUpdate retrieves the numpool row with the given id and locks it for update.
func (q *Queries) GetNumpoolForUpdate(ctx context.Context, id string) (Numpool, error) {
	row := q.db.QueryRow(ctx, getNumpoolForUpdate, id)
	var i Numpool
	err := row.Scan(
		&i.ID,
		&i.MaxResourcesCount,
		&i.ResourceUsageStatus,
		&i.WaitQueue,
		&i.Metadata,
	)
	return i, err
}

const lockNumpoolTableInShareMode = `-- name: LockNumpoolTableInShareMode :exec
LOCK TABLE numpools IN SHARE ROW EXCLUSIVE MODE
`

func (q *Queries) LockNumpoolTableInShareMode(ctx context.Context) error {
	_, err := q.db.Exec(ctx, lockNumpoolTableInShareMode)
	return err
}

const notifyWaiters = `-- name: NotifyWaiters :exec
SELECT pg_notify($1, $2)
`

type NotifyWaitersParams struct {
	ChannelName string
	WaiterID    string
}

func (q *Queries) NotifyWaiters(ctx context.Context, arg NotifyWaitersParams) error {
	_, err := q.db.Exec(ctx, notifyWaiters, arg.ChannelName, arg.WaiterID)
	return err
}

const releaseResource = `-- name: ReleaseResource :execrows
UPDATE numpools
SET resource_usage_status = resource_usage_status & ~(1::BIT(64) << (63 - $2))
WHERE id = $1
	AND (resource_usage_status & (1::BIT(64) << (63 - $2))) <> 0::BIT(64)
`

type ReleaseResourceParams struct {
	ID            string
	ResourceIndex interface{}
}

// ReleaseResource releases a resource back to the numpool.
func (q *Queries) ReleaseResource(ctx context.Context, arg ReleaseResourceParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseResource, arg.ID, arg.ResourceIndex)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const removeFromWaitQueue = `-- name: RemoveFromWaitQueue :exec
UPDATE numpools
SET wait_queue = array_remove(wait_queue, $2)
WHERE id = $1
`

type RemoveFromWaitQueueParams struct {
	ID       string
	WaiterID interface{}
}

// RemoveFromWaitQueue removes a specific waiter UUID from the wait queue.
func (q *Queries) RemoveFromWaitQueue(ctx context.Context, arg RemoveFromWaitQueueParams) error {
	_, err := q.db.Exec(ctx, removeFromWaitQueue, arg.ID, arg.WaiterID)
	return err
}

const updateNumpoolMetadata = `-- name: UpdateNumpoolMetadata :exec
UPDATE numpools
SET metadata = $2
WHERE id = $1
`

type UpdateNumpoolMetadataParams struct {
	ID       string
	Metadata []byte
}

// UpdateNumpoolMetadata updates the metadata of the numpool with the specified id.
func (q *Queries) UpdateNumpoolMetadata(ctx context.Context, arg UpdateNumpoolMetadataParams) error {
	_, err := q.db.Exec(ctx, updateNumpoolMetadata, arg.ID, arg.Metadata)
	return err
}
